---
description: 
globs: 
alwaysApply: false
---
# 开发模式和最佳实践

## 代码组织原则

### 前端JavaScript模式
- **类组织**: 使用ES6类组织代码，如[frontend/static/js/app.js](mdc:frontend/static/js/app.js)中的`DetectiveGameApp`类
- **方法命名**: 使用驼峰命名法，方法名应清晰表达功能
- **状态管理**: 集中管理应用状态，避免全局变量污染
- **模块化**: 将相关功能组织在类方法中，保持代码结构清晰

### 后端API设计
- **RESTful设计**: 遵循REST原则设计API端点
- **相对导入**: 后端模块间使用相对导入：`from .module_name import ClassName`
- **错误处理**: 统一错误响应格式，包含错误码和消息
- **会话管理**: 使用session_id管理用户会话状态
- **包结构**: 所有后端代码在backend包中，确保`__init__.py`存在

### 项目结构规范
```
backend/                    # 后端服务包
├── __init__.py            # 包初始化文件（必需）
├── app.py                 # FastAPI主应用
├── game_engine.py         # 游戏引擎
├── ai_service.py          # AI服务
├── models.py              # 数据模型
├── case_data.py           # 案例数据
├── evidence_system.py     # 证据系统
├── accusation_system.py   # 指控系统
└── config.py              # 配置管理

frontend/                   # 前端应用
├── index.html             # 主页面
└── static/
    ├── css/style.css      # 样式文件
    └── js/app.js          # 应用逻辑

legacy/                     # 命令行版本
├── detective_game.py      # 主程序
├── detective_ui.py        # 界面组件
└── start_detective.py     # 启动脚本
```

## 异步编程模式

### JavaScript异步处理
```javascript
// 推荐：使用async/await处理API调用
async askQuestion(question, character) {
    try {
        this.showLoading('正在思考中...');
        
        const response = await fetch('/api/game/question', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                session_id: this.sessionId,
                character_name: character,
                question: question
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error('请求失败:', error);
        this.showError('请求失败，请重试');
        throw error;
    } finally {
        this.hideLoading();
    }
}

// 流式响应处理
async handleStreamResponse(url, data) {
    const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
    });
    
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        for (const line of lines) {
            if (line.startsWith('data: ')) {
                const data = JSON.parse(line.slice(6));
                this.handleStreamChunk(data);
            }
        }
    }
}
```

### Python异步处理
```python
# 推荐：FastAPI异步端点
@app.post("/api/game/question")
async def ask_question(request: QuestionRequest):
    try:
        # 获取游戏会话
        if request.session_id not in game_sessions:
            raise HTTPException(status_code=404, detail="游戏会话不存在")
        
        game_engine = game_sessions[request.session_id]
        
        # 异步处理AI响应
        response = await game_engine.process_question(
            request.character_name, 
            request.question
        )
        
        return {"success": True, "data": response}
        
    except Exception as e:
        logger.error(f"处理问题时出错: {str(e)}")
        return {"success": False, "error": str(e)}

# 流式响应生成器
async def generate_stream_response(prompt: str):
    try:
        async for chunk in ai_service.get_stream_response(prompt):
            yield f"data: {json.dumps({'type': 'chunk', 'content': chunk})}\n\n"
            await asyncio.sleep(0.01)  # 小延迟确保流畅显示
        
        yield f"data: {json.dumps({'type': 'complete'})}\n\n"
        
    except Exception as e:
        yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"
```

## UI/UX开发模式

### 响应式设计原则
```css
/* 移动优先设计 */
.game-container {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;
}

/* 平板断点 */
@media (min-width: 768px) {
    .game-container {
        padding: 2rem;
    }
    
    .character-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

/* 桌面断点 */
@media (min-width: 1024px) {
    .character-grid {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .conversation-area {
        height: 400px;
    }
}
```

### 交互反馈模式
```javascript
// 加载状态管理
showLoading(message = '加载中...') {
    const loadingEl = document.getElementById('loading-indicator');
    loadingEl.textContent = message;
    loadingEl.style.display = 'block';
}

hideLoading() {
    const loadingEl = document.getElementById('loading-indicator');
    loadingEl.style.display = 'none';
}

// 错误处理
showError(message, duration = 5000) {
    const errorEl = document.createElement('div');
    errorEl.className = 'error-toast';
    errorEl.textContent = message;
    
    document.body.appendChild(errorEl);
    
    // 自动消失
    setTimeout(() => {
        errorEl.classList.add('fade-out');
        setTimeout(() => errorEl.remove(), 300);
    }, duration);
}

// 成功反馈
showSuccess(message, duration = 3000) {
    const successEl = document.createElement('div');
    successEl.className = 'success-toast';
    successEl.textContent = message;
    
    document.body.appendChild(successEl);
    setTimeout(() => successEl.remove(), duration);
}
```

### 动画和过渡
```css
/* 平滑过渡效果 */
.button {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    transform: translateY(0);
}

.button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* 页面切换动画 */
.screen {
    opacity: 0;
    transform: translateX(20px);
    transition: all 0.4s ease-out;
}

.screen.active {
    opacity: 1;
    transform: translateX(0);
}

/* 流式文本动画 */
@keyframes typewriter {
    from { width: 0; }
    to { width: 100%; }
}

.streaming-text {
    overflow: hidden;
    white-space: nowrap;
    animation: typewriter 0.1s steps(1) forwards;
}
```

## 数据流管理

### 前端数据流架构
```javascript
class DetectiveGameApp {
    constructor() {
        // 集中状态管理
        this.gameState = {
            sessionId: null,
            currentCase: null,
            selectedCharacter: null,
            conversationHistory: [],
            gamePhase: 'menu' // menu, case-selection, investigation, accusation
        };
        
        // WebSocket连接
        this.ws = null;
        this.wsReconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }
    
    // 状态更新方法
    updateGameState(newState) {
        this.gameState = { ...this.gameState, ...newState };
        this.onStateChange();
    }
    
    // 状态变化处理
    onStateChange() {
        // 更新UI
        this.updateUI();
        
        // 保存到本地存储
        this.saveGameState();
        
        // 通过WebSocket同步
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({
                type: 'state_update',
                data: this.gameState
            }));
        }
    }
}
```

### 后端数据流处理
```python
class DetectiveGameEngine:
    def __init__(self):
        self.ai_service = AIService()
        self.evidence_system = EvidenceSystem(self.ai_service)
        self.accusation_system = AccusationSystem(self.ai_service, self.evidence_system)
        
        # 游戏状态
        self.current_case: Optional[Case] = None
        self.conversation_history: Dict[str, List[Dict]] = {}
        self.current_round = 0
        self.hints_used = 0
        
    async def process_question(self, character_name: str, question: str) -> Dict:
        """处理玩家问题的完整流程"""
        try:
            # 1. 验证输入
            character = self._find_character(character_name)
            if not character:
                raise ValueError(f"角色 {character_name} 不存在")
            
            # 2. 检查证据揭露
            revealed_evidence = await self.evidence_system.try_reveal_evidence(
                character, question, self.current_case
            )
            
            # 3. 生成AI响应
            response = await self._get_character_response(character, question)
            
            # 4. 更新对话历史
            self._update_conversation_history(character_name, question, response)
            
            # 5. 增加回合数
            self.current_round += 1
            
            # 6. 返回结果
            return {
                "character": character_name,
                "response": response,
                "revealed_evidence": revealed_evidence.to_dict() if revealed_evidence else None,
                "round_number": self.current_round,
                "remaining_rounds": self.max_rounds - self.current_round
            }
            
        except Exception as e:
            logger.error(f"处理问题时出错: {str(e)}")
            raise
```

## 错误处理策略

### 前端错误处理
```javascript
class ErrorHandler {
    static async handleApiError(error, context = '') {
        console.error(`API错误 ${context}:`, error);
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            this.showNetworkError();
        } else if (error.status === 404) {
            this.showNotFoundError();
        } else if (error.status >= 500) {
            this.showServerError();
        } else {
            this.showGenericError(error.message);
        }
    }
    
    static showNetworkError() {
        this.showError('网络连接失败，请检查网络设置');
    }
    
    static showServerError() {
        this.showError('服务器暂时不可用，请稍后重试');
    }
    
    static showError(message) {
        // 显示用户友好的错误消息
        const app = window.detectiveGame;
        if (app) {
            app.showError(message);
        }
    }
}

// 全局错误处理
window.addEventListener('unhandledrejection', (event) => {
    console.error('未处理的Promise拒绝:', event.reason);
    ErrorHandler.handleApiError(event.reason, '全局错误');
    event.preventDefault();
});
```

### 后端错误处理
```python
import logging
from fastapi import HTTPException
from fastapi.responses import JSONResponse

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('game.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# 自定义异常类
class GameError(Exception):
    def __init__(self, message: str, error_code: str = "GAME_ERROR"):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)

class AIServiceError(GameError):
    def __init__(self, message: str):
        super().__init__(message, "AI_SERVICE_ERROR")

# 全局异常处理器
@app.exception_handler(GameError)
async def game_error_handler(request: Request, exc: GameError):
    logger.error(f"游戏错误: {exc.error_code} - {exc.message}")
    return JSONResponse(
        status_code=400,
        content={
            "success": False,
            "error": exc.message,
            "error_code": exc.error_code
        }
    )

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"未处理的异常: {type(exc).__name__} - {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "success": False,
            "error": "服务器内部错误",
            "error_code": "INTERNAL_ERROR"
        }
    )
```

## 性能优化原则

### 前端优化策略
```javascript
// 防抖处理用户输入
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// 使用防抖处理搜索输入
const debouncedSearch = debounce((query) => {
    this.searchCharacters(query);
}, 300);

// 虚拟滚动处理大量对话历史
class VirtualScrollManager {
    constructor(container, itemHeight = 60) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;
    }
    
    render(items, startIndex = 0) {
        const endIndex = Math.min(startIndex + this.visibleItems, items.length);
        const visibleItems = items.slice(startIndex, endIndex);
        
        // 只渲染可见项目
        this.container.innerHTML = visibleItems.map(item => 
            this.renderItem(item)
        ).join('');
    }
}

// 图片懒加载
class LazyImageLoader {
    constructor() {
        this.observer = new IntersectionObserver(this.handleIntersection.bind(this));
    }
    
    observe(img) {
        this.observer.observe(img);
    }
    
    handleIntersection(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                this.observer.unobserve(img);
            }
        });
    }
}
```

### 后端优化策略
```python
import asyncio
from functools import lru_cache
from typing import Dict, Any

# 缓存装饰器
@lru_cache(maxsize=128)
def get_character_prompt_template(character_type: str) -> str:
    """缓存角色提示模板"""
    return load_prompt_template(character_type)

# 异步批处理
class BatchProcessor:
    def __init__(self, batch_size: int = 10, delay: float = 0.1):
        self.batch_size = batch_size
        self.delay = delay
        self.queue = []
        
    async def add_task(self, task):
        self.queue.append(task)
        
        if len(self.queue) >= self.batch_size:
            await self.process_batch()
    
    async def process_batch(self):
        if not self.queue:
            return
            
        batch = self.queue[:self.batch_size]
        self.queue = self.queue[self.batch_size:]
        
        # 并行处理批次
        results = await asyncio.gather(*batch, return_exceptions=True)
        
        # 处理结果
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"批处理任务失败: {result}")

# 连接池管理
class ConnectionManager:
    def __init__(self, max_connections: int = 100):
        self.max_connections = max_connections
        self.active_connections: Dict[str, Any] = {}
        
    async def get_connection(self, session_id: str):
        if session_id not in self.active_connections:
            if len(self.active_connections) >= self.max_connections:
                # 清理最旧的连接
                oldest_session = min(self.active_connections.keys())
                await self.close_connection(oldest_session)
            
            self.active_connections[session_id] = await self.create_connection()
        
        return self.active_connections[session_id]
```

## 测试策略

### 前端测试
```javascript
// 单元测试示例
describe('DetectiveGameApp', () => {
    let app;
    
    beforeEach(() => {
        app = new DetectiveGameApp();
    });
    
    test('应该正确初始化游戏状态', () => {
        expect(app.gameState.sessionId).toBeNull();
        expect(app.gameState.currentCase).toBeNull();
        expect(app.gameState.gamePhase).toBe('menu');
    });
    
    test('应该正确处理角色选择', () => {
        const character = { name: '角色名称', occupation: '职业' };
        app.selectCharacter(character);
        
        expect(app.gameState.selectedCharacter).toBe(character.name);
    });
});

// 集成测试
describe('API集成测试', () => {
    test('应该能够开始新游戏', async () => {
        const response = await fetch('/api/game/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ case_index: 0 })
        });
        
        expect(response.ok).toBe(true);
        const data = await response.json();
        expect(data.session_id).toBeDefined();
    });
});
```

### 后端测试
```python
import pytest
from fastapi.testclient import TestClient
from backend.app import app

client = TestClient(app)

class TestGameAPI:
    def test_start_game(self):
        """测试开始游戏API"""
        response = client.post("/api/game/start", json={"case_index": 0})
        assert response.status_code == 200
        
        data = response.json()
        assert "session_id" in data
        assert "case" in data
        
    def test_ask_question(self):
        """测试提问API"""
        # 先开始游戏
        start_response = client.post("/api/game/start", json={"case_index": 0})
        session_id = start_response.json()["session_id"]
        
        # 提问
        question_response = client.post("/api/game/question", json={
            "session_id": session_id,
            "character_name": "角色名称",
            "question": "你昨晚在做什么？"
        })
        
        assert question_response.status_code == 200
        data = question_response.json()
        assert data["success"] is True
        assert "response" in data["data"]

# 性能测试
@pytest.mark.asyncio
async def test_concurrent_requests():
    """测试并发请求处理"""
    import asyncio
    import aiohttp
    
    async def make_request(session):
        async with session.post('http://localhost:8000/api/game/start', 
                               json={'case_index': 0}) as response:
            return await response.json()
    
    async with aiohttp.ClientSession() as session:
        tasks = [make_request(session) for _ in range(10)]
        results = await asyncio.gather(*tasks)
        
        # 验证所有请求都成功
        for result in results:
            assert 'session_id' in result
```

## 代码审查清单

### 代码质量检查
- [ ] 变量和函数命名清晰且符合约定
- [ ] 代码注释充分且准确
- [ ] 错误处理完整且用户友好
- [ ] 性能考虑合理，避免不必要的计算
- [ ] 导入路径正确，使用相对导入
- [ ] 异步操作正确处理，避免阻塞

### 安全性检查
- [ ] 输入验证和清理完整
- [ ] API密钥安全存储，不暴露在前端
- [ ] CORS配置正确且安全
- [ ] 敏感信息不在日志中暴露
- [ ] 会话管理安全，防止会话劫持

### 可维护性检查
- [ ] 代码结构清晰，职责分离
- [ ] 模块化程度高，耦合度低
- [ ] 依赖关系简单明确
- [ ] 文档完整准确，包含使用示例
- [ ] 测试覆盖率足够，包含边界情况

### 用户体验检查
- [ ] 加载状态明确，用户不会困惑
- [ ] 错误消息友好且可操作
- [ ] 响应式设计在各设备上正常
- [ ] 动画流畅，不影响性能
- [ ] 无障碍性考虑，支持键盘导航





