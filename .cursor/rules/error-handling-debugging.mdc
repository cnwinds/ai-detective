---
description:
globs:
alwaysApply: false
---
# 错误处理和调试指南

## 错误处理架构

### 全局错误处理系统
[backend/app.py](mdc:backend/app.py)中实现了完整的错误处理系统：

**全局异常处理器**：
```python
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """全局异常处理器 - 捕获所有未处理的异常"""
    logger.error(f"全局异常处理器捕获异常: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "success": False,
            "error": "服务器内部错误",
            "detail": str(exc) if app.debug else "请联系管理员"
        }
    )
```

**请求日志中间件**：
```python
@app.middleware("http")
async def log_requests(request: Request, call_next):
    """请求日志中间件"""
    start_time = time.time()
    logger.info(f"请求开始: {request.method} {request.url}")
    
    response = await call_next(request)
    
    process_time = time.time() - start_time
    logger.info(f"请求完成: {request.method} {request.url} - 状态码: {response.status_code} - 耗时: {process_time:.3f}s")
    
    return response
```

### API端点错误处理模式

**标准错误处理模板**：
```python
@app.post("/api/game/start")
async def start_game(request: StartGameRequest):
    try:
        logger.info(f"开始游戏请求 - 案例索引: {request.case_index}")
        
        # 参数验证
        if request.case_index < 0 or request.case_index >= len(game_engine.cases):
            logger.warning(f"无效的案例索引: {request.case_index}")
            raise HTTPException(status_code=400, detail=f"无效的案例索引: {request.case_index}")
        
        # 业务逻辑处理
        session_id = str(uuid.uuid4())
        logger.info(f"生成会话ID: {session_id}")
        
        # 成功响应
        logger.info(f"游戏开始成功 - 会话ID: {session_id}")
        return {"success": True, "session_id": session_id, "case": case_info}
        
    except HTTPException:
        # 重新抛出HTTP异常
        raise
    except Exception as e:
        # 记录详细错误信息
        logger.error(f"开始游戏时出错: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"开始游戏失败: {str(e)}")
```

### 流式响应错误处理

**流式API错误处理**：
```python
@app.post("/api/game/question/stream")
async def ask_question_stream(request: QuestionRequest):
    async def generate_response():
        try:
            logger.info(f"流式问答请求 - 会话: {request.session_id}, 角色: {request.character_name}")
            
            # 验证会话
            if request.session_id not in game_sessions:
                yield f"data: {json.dumps({'type': 'error', 'message': '游戏会话不存在'})}\n\n"
                return
            
            # 流式处理
            async for chunk in game_engine.generate_response_stream(request):
                if chunk:
                    yield f"data: {json.dumps({'type': 'chunk', 'content': chunk})}\n\n"
            
            yield f"data: {json.dumps({'type': 'complete'})}\n\n"
            
        except Exception as e:
            logger.error(f"流式问答出错: {str(e)}", exc_info=True)
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"
    
    return StreamingResponse(generate_response(), media_type="text/plain")
```

## 日志记录规范

### 日志级别使用
- **DEBUG**: 详细的调试信息，仅在开发环境使用
- **INFO**: 一般信息，记录正常的业务流程
- **WARNING**: 警告信息，可能的问题但不影响功能
- **ERROR**: 错误信息，功能异常但程序可继续运行
- **CRITICAL**: 严重错误，程序无法继续运行

### 日志记录最佳实践

**业务流程日志**：
```python
# 记录关键业务步骤
logger.info(f"开始游戏 - 案例: {case.title}, 会话: {session_id}")
logger.info(f"角色对话 - 角色: {character.name}, 问题长度: {len(question)}")
logger.info(f"指控处理 - 被告: {accused.name}, 指控者: 侦探")

# 记录重要状态变化
logger.info(f"证据揭露 - 证据: {evidence.title}, 触发角色: {character.name}")
logger.info(f"游戏结束 - 结果: {'胜利' if is_correct else '失败'}, 会话: {session_id}")
```

**错误日志记录**：
```python
# 记录异常详情
logger.error(f"AI服务调用失败 - 角色: {character.name}, 错误: {str(e)}", exc_info=True)
logger.error(f"数据库操作失败 - 操作: 保存游戏状态, 错误: {str(e)}", exc_info=True)

# 记录业务逻辑错误
logger.warning(f"无效的角色名称: {character_name}, 会话: {session_id}")
logger.warning(f"重复的证据揭露尝试 - 证据: {evidence.title}")
```

**性能监控日志**：
```python
# 记录处理时间
start_time = time.time()
# ... 业务处理
process_time = time.time() - start_time
logger.info(f"AI响应生成完成 - 耗时: {process_time:.3f}s, 字符数: {len(response)}")
```

## 调试技巧

### 前端调试
**浏览器开发者工具**：
```javascript
// 在关键位置添加调试信息
console.log('发送问题请求:', {
    session_id: this.sessionId,
    character_name: character,
    question: question
});

// 监控API响应
fetch('/api/game/question', requestOptions)
    .then(response => {
        console.log('API响应状态:', response.status);
        return response.json();
    })
    .then(data => {
        console.log('API响应数据:', data);
    })
    .catch(error => {
        console.error('API请求失败:', error);
    });
```

**状态调试**：
```javascript
// 在DetectiveGameApp类中添加调试方法
debugGameState() {
    console.log('当前游戏状态:', {
        sessionId: this.sessionId,
        currentCase: this.currentCase,
        conversationHistory: this.conversationHistory,
        currentScreen: this.currentScreen
    });
}

// 在关键操作后调用
this.debugGameState();
```

### 后端调试
**详细的函数调用日志**：
```python
def _generate_vote_stream(self, voter, accusation, case, conversation_history):
    logger.debug(f"开始生成投票流 - 投票者: {voter.name}, 被告: {accusation.accused.name}")
    
    # 记录输入参数
    logger.debug(f"对话历史长度: {len(conversation_history.get(voter.name, []))}")
    logger.debug(f"证人证词数量: {len(accusation.witness_testimonies)}")
    
    try:
        # 业务逻辑
        result = self._process_vote_logic(voter, accusation)
        logger.debug(f"投票处理完成 - 结果: {result}")
        return result
    except Exception as e:
        logger.error(f"投票生成失败 - 投票者: {voter.name}, 错误: {str(e)}", exc_info=True)
        raise
```

**数据结构验证**：
```python
def validate_accusation_data(self, accusation):
    """验证指控数据的完整性"""
    assert accusation.accused is not None, "被告不能为空"
    assert accusation.accuser_reasoning, "指控理由不能为空"
    assert len(accusation.witness_testimonies) > 0, "必须有证人证词"
    logger.debug(f"指控数据验证通过 - 被告: {accusation.accused.name}")
```

## 常见错误解决方案

### HTTP 405 Method Not Allowed
**问题**：客户端使用错误的HTTP方法访问API端点
```javascript
// 错误：使用GET访问POST端点
fetch('/api/game/start', { method: 'GET' })

// 正确：使用POST方法
fetch('/api/game/start', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestData)
})
```

### HTTP 500 Internal Server Error
**问题**：服务器内部错误，通常是代码bug
```python
# 常见错误：访问不存在的属性
cases[request.case_index]  # 错误：cases未定义

# 正确：使用正确的对象引用
game_engine.cases[request.case_index]
```

### 会话管理错误
**问题**：会话ID不存在或已过期
```python
# 添加会话验证
if session_id not in game_sessions:
    logger.warning(f"会话不存在: {session_id}")
    raise HTTPException(status_code=404, detail="游戏会话不存在")

# 会话清理机制
def cleanup_expired_sessions():
    current_time = time.time()
    expired_sessions = [
        sid for sid, session in game_sessions.items()
        if current_time - session.last_activity > SESSION_TIMEOUT
    ]
    for sid in expired_sessions:
        del game_sessions[sid]
        logger.info(f"清理过期会话: {sid}")
```

### 流式响应中断
**问题**：流式响应过程中出现错误
```python
async def safe_stream_response(self, generator):
    """安全的流式响应包装器"""
    try:
        async for chunk in generator:
            if chunk:
                yield f"data: {json.dumps({'type': 'chunk', 'content': chunk})}\n\n"
        yield f"data: {json.dumps({'type': 'complete'})}\n\n"
    except Exception as e:
        logger.error(f"流式响应出错: {str(e)}", exc_info=True)
        yield f"data: {json.dumps({'type': 'error', 'message': '响应生成失败'})}\n\n"
```

## 性能监控

### 响应时间监控
```python
import time
from functools import wraps

def monitor_performance(func):
    """性能监控装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"{func.__name__} 执行完成 - 耗时: {duration:.3f}s")
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"{func.__name__} 执行失败 - 耗时: {duration:.3f}s, 错误: {str(e)}")
            raise
    return wrapper

# 使用装饰器
@monitor_performance
async def generate_ai_response(self, prompt):
    # AI响应生成逻辑
    pass
```

### 内存使用监控
```python
import psutil
import os

def log_memory_usage(operation_name):
    """记录内存使用情况"""
    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()
    logger.info(f"{operation_name} - 内存使用: {memory_info.rss / 1024 / 1024:.2f} MB")

# 在关键操作前后调用
log_memory_usage("游戏开始前")
# ... 游戏逻辑
log_memory_usage("游戏开始后")
```

## 测试和验证

### 单元测试模式
```python
import pytest
from unittest.mock import Mock, patch

class TestAccusationSystem:
    def test_parse_vote_result_support(self):
        """测试投票解析 - 支持"""
        system = AccusationSystem(Mock())
        vote_text = "我支持这个指控。理由：证据很充分"
        
        vote, reason = system._parse_vote_result(vote_text)
        
        assert vote == "支持"
        assert reason == "证据很充分"
    
    def test_parse_vote_result_oppose(self):
        """测试投票解析 - 反对"""
        system = AccusationSystem(Mock())
        vote_text = "我反对这个指控。理由：证据不足"
        
        vote, reason = system._parse_vote_result(vote_text)
        
        assert vote == "反对"
        assert reason == "证据不足"
```

### 集成测试
```python
import httpx
import pytest

@pytest.mark.asyncio
async def test_game_start_api():
    """测试游戏开始API"""
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/api/game/start", json={"case_index": 0})
        
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert "session_id" in data
        assert "case" in data
```

## 生产环境监控

### 日志聚合
- 使用ELK Stack (Elasticsearch, Logstash, Kibana)
- 配置日志轮转避免磁盘空间不足
- 设置关键错误的告警机制

### 健康检查端点
```python
@app.get("/health")
async def health_check():
    """健康检查端点"""
    try:
        # 检查关键服务状态
        ai_service_status = await check_ai_service()
        database_status = await check_database()
        
        return {
            "status": "healthy",
            "services": {
                "ai_service": ai_service_status,
                "database": database_status
            },
            "timestamp": time.time()
        }
    except Exception as e:
        logger.error(f"健康检查失败: {str(e)}")
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": time.time()
        }
```

### 错误率监控
```python
# 错误统计
error_counter = {"total_requests": 0, "error_requests": 0}

@app.middleware("http")
async def error_tracking_middleware(request: Request, call_next):
    error_counter["total_requests"] += 1
    
    response = await call_next(request)
    
    if response.status_code >= 400:
        error_counter["error_requests"] += 1
        
        # 计算错误率
        error_rate = error_counter["error_requests"] / error_counter["total_requests"]
        if error_rate > 0.05:  # 错误率超过5%
            logger.warning(f"错误率过高: {error_rate:.2%}")
    
    return response
```
